# Compute & Postprocess Example

This example demonstrates a two-stage graphics pipeline:

## Architecture

### Stage 1: Compute Pass
- **Compute Shader** (`generate.comp`): Generates an animated procedural pattern
  - Uses a 16x16 local work group size
  - Writes directly to a storage image (R8G8B8A8 format)
  - Creates animated sine/cosine wave patterns based on time
  - Output: 800x600 texture with generated pattern

### Stage 2: Render Pass
- **Vertex Shader** (`fullscreen.vert`): Generates a fullscreen quad without vertex buffers
  - Hardcoded 6 vertices for two triangles
  - Outputs texture coordinates
  
- **Fragment Shader** (`postprocess.frag`): Post-processes the compute output
  - Samples the texture generated by compute shader
  - Applies vignette effect
  - Adds animated color shifts
  - Renders to swapchain

## Key Features

1. **Compute-to-Graphics Pipeline**: Demonstrates compute shader output being used as render input
2. **Pipeline Barriers**: Shows proper synchronization between compute and fragment shader stages
3. **Storage Images**: Compute shader writes to storage image (writeonly)
4. **Texture Sampling**: Fragment shader reads from same texture as sampled texture
5. **Layout Transitions**: Manages texture layout transitions (GENERAL → SHADER_READ_ONLY → PRESENT_SRC)

## Build & Run

```bash
cd build
ninja compute_example_c
./compute_example_c
```

## Controls

- **ESC**: Exit application

## Technical Notes

- Uses explicit synchronization with semaphores and fences
- No vertex buffers needed (fullscreen quad generated in vertex shader)
- Demonstrates workflow: Compute generates data → Render displays/processes it
- Good example for post-processing effects, particle systems, or procedural generation
